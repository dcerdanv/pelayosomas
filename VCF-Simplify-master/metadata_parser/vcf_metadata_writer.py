import collections
import json
import pprint


from .vcf_metadata_parser import VcfReadMetaData


class Write_Simplified_MetaData:
    """Write the simplified VCF records generated by class 'VcfMetaDataParser' to a file"""

    def __init__(self, metadict, outFile, as_dict, as_json, as_table):
        if not isinstance(metadict, dict):
            raise ValueError  # what if we raise the dict object is empty or not-generated??

        self.metadict = metadict
        self.outFile = outFile

        ## check truth and write if the data output type is requested
        self.write_records_asdict = as_dict
        self.write_records_asjson = as_json
        self.write_records_astable = as_table

    def write_or_print(self):
        """write the output to the appropriate data format"""
        if self.write_records_asdict == True:
            self.vcf_records_grouped_dict(self.metadict, self.outFile)

        if self.write_records_asjson == True:
            self.vcf_records_as_json(self.metadict, self.outFile)

        if self.write_records_astable == True:
            self.vcf_records_as_table(self.metadict, self.outFile)

    @staticmethod
    # def vcf_records_grouped_dict(metadict):
    def vcf_records_grouped_dict(metadict, outFile):
        """Converts the json type dictionary to 
        dictionary that has all the values under same keys in one list of values.
        """
        grouped_dict = collections.OrderedDict()
        for kyes, vyes in metadict.items():
            nested_dict = collections.OrderedDict()
            for elements in vyes:
                # if type(elements) == dict:
                for nes_ks, nes_vs in elements.items():
                    if nes_ks not in nested_dict:
                        nested_dict[nes_ks] = [nes_vs]
                    else:
                        nested_dict[nes_ks].append(nes_vs)

            grouped_dict[kyes] = nested_dict

        ## Write the grouped dict to a file as shown in prettyprint
        print("\twriting metadata as dictionary.")
        with open("%s.dict" % outFile, "w", encoding="utf-8") as write_as_dict:
            pprint.pprint(grouped_dict, stream=write_as_dict)

    @staticmethod
    def vcf_records_as_json(metadict, outFile):
        """Convert the dictionary to a json object and write to a file"""
        print("\twriting metadata as JSON")

        json_obj_string = json.dumps(metadict)
        datastore = json.loads(json_obj_string)

        with open("%s.json" % outFile, "w", encoding="utf-8") as write_as_json:
            json.dump(datastore, write_as_json, ensure_ascii=False, indent=4)

    @staticmethod
    def vcf_records_as_table(metadict, outFile):
        """write data to a file as text"""
        print("\twriting metadata as table")
        with open("%s.table" % outFile, "w", encoding="utf-8") as write_as_table:
            for (
                ks_parent,
                vs_parent,
            ) in metadict.items():  # parent keys and parent values
                # ?? - why is there extra comma at the end of the tuple ??
                write_as_table.write(r"##" + ks_parent + "\n")
                write_as_table.write(r"#")
                vs_keys_to_write = [kys for kys, vys in vs_parent[0].items()]
                write_as_table.write("\t".join(vs_keys_to_write) + "\n")

                for nested_vs in vs_parent:
                    vs_vs_to_write = []
                    for _, vs_child in nested_vs.items():
                        vs_vs_to_write.append(str(vs_child))
                    write_as_table.write("\t".join(vs_vs_to_write))
                    write_as_table.write("\n")
                write_as_table.write("\n\n")
